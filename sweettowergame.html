<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>🍰 Sweet Tower 甜點塔疊疊樂</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: linear-gradient(180deg, #fff5f7 0%, #ffe4e9 50%, #ffd4e0 100%);
    overflow: hidden;
    font-family: 'Comic Sans MS', 'Arial', sans-serif;
    height: 100vh;
    position: relative;
  }
  
  /* 可愛的雲朵背景 */
  .cloud {
    position: absolute;
    background: rgba(255, 255, 255, 0.7);
    border-radius: 100px;
    animation: float-cloud 20s infinite linear;
  }
  .cloud::before, .cloud::after {
    content: '';
    position: absolute;
    background: rgba(255, 255, 255, 0.7);
    border-radius: 100px;
  }
  @keyframes float-cloud {
    from { transform: translateX(-200px); }
    to { transform: translateX(100vw); }
  }
  
  canvas {
    display: block;
    margin: 0 auto;
    max-width: 100%;
    max-height: 100vh;
    box-shadow: 0 10px 40px rgba(255, 182, 193, 0.3);
    border-radius: 20px;
  }
  
  #game-container {
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
  }
  
  #ui {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    text-align: center;
    z-index: 10;
  }
  
  #score {
    font-size: 36px;
    font-weight: bold;
    color: #ff69b4;
    text-shadow: 2px 2px 4px rgba(255, 105, 180, 0.3);
    margin-bottom: 10px;
  }
  
  #level {
    font-size: 20px;
    color: #ff8fab;
    background: rgba(255, 255, 255, 0.8);
    padding: 8px 20px;
    border-radius: 20px;
    display: inline-block;
    box-shadow: 0 4px 10px rgba(255, 182, 193, 0.3);
  }
  
  #instructions {
    position: fixed;
    top: 100px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(255, 255, 255, 0.9);
    padding: 12px 25px;
    border-radius: 20px;
    font-size: 16px;
    color: #ff69b4;
    box-shadow: 0 4px 15px rgba(255, 182, 193, 0.4);
    font-weight: bold;
    animation: fade-hint 3s ease-in-out infinite;
  }
  
  @keyframes fade-hint {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
  }
  
  #game-over {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(255, 255, 255, 0.95);
    padding: 40px 60px;
    border-radius: 30px;
    text-align: center;
    box-shadow: 0 10px 40px rgba(255, 105, 180, 0.4);
    display: none;
    z-index: 100;
  }
  
  #game-over h1 {
    font-size: 48px;
    color: #ff69b4;
    margin-bottom: 20px;
  }
  
  #final-score {
    font-size: 32px;
    color: #ff8fab;
    margin-bottom: 30px;
  }
  
  #restart-btn {
    background: linear-gradient(135deg, #ff69b4, #ff8fab);
    color: white;
    border: none;
    padding: 15px 40px;
    font-size: 24px;
    border-radius: 25px;
    cursor: pointer;
    font-weight: bold;
    box-shadow: 0 6px 20px rgba(255, 105, 180, 0.4);
    transition: transform 0.2s;
  }
  
  #restart-btn:hover {
    transform: scale(1.1);
  }
  
  #restart-btn:active {
    transform: scale(0.95);
  }
  
  .sparkle {
    position: fixed;
    pointer-events: none;
    font-size: 20px;
    animation: sparkle-float 1s ease-out forwards;
  }
  
  @keyframes sparkle-float {
    to {
      transform: translateY(-100px) scale(1.5);
      opacity: 0;
    }
  }
</style>
</head>
<body>
<!-- 背景雲朵 -->
<div class="cloud" style="width:80px;height:40px;top:10%;left:-100px;animation-delay:0s;"></div>
<div class="cloud" style="width:120px;height:50px;top:25%;left:-150px;animation-delay:5s;"></div>
<div class="cloud" style="width:100px;height:45px;top:60%;left:-120px;animation-delay:10s;"></div>
<div class="cloud" style="width:90px;height:42px;top:80%;left:-110px;animation-delay:15s;"></div>

<div id="game-container">
  <canvas id="game"></canvas>
</div>

<div id="ui">
  <div id="score">🍰 高度: 0</div>
  <div id="level">Level 1</div>
</div>

<div id="instructions">點擊放下甜點！疊得越高越好 🎂</div>

<div id="game-over">
  <h1>🎉 遊戲結束 🎉</h1>
  <div id="final-score">最終高度: 0</div>
  <button id="restart-btn">再玩一次！</button>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = 400;
canvas.height = 700;

// 遊戲狀態
let gameState = 'playing'; // playing, gameover
let score = 0;
let level = 1;
let speed = 2;

// 甜點類型
const dessertTypes = [
  { 
    name: 'cake', 
    emoji: '🍰', 
    colors: ['#ffb6d9', '#fff0f5', '#ffe4e9'],
    width: 80 
  },
  { 
    name: 'cupcake', 
    emoji: '🧁', 
    colors: ['#ffd4e0', '#ffe4f0', '#fff5f7'],
    width: 70 
  },
  { 
    name: 'donut', 
    emoji: '🍩', 
    colors: ['#ffb3d9', '#ffd6e8', '#ffe9f2'],
    width: 75 
  },
  { 
    name: 'pie', 
    emoji: '🥧', 
    colors: ['#ffc4dd', '#ffe0ed', '#fff0f5'],
    width: 85 
  },
  { 
    name: 'cookie', 
    emoji: '🍪', 
    colors: ['#d4a574', '#e6c8a0', '#f5e6d3'],
    width: 65 
  },
  { 
    name: 'icecream', 
    emoji: '🍦', 
    colors: ['#ffd9ec', '#ffe9f5', '#fff5fa'],
    width: 60 
  },
  { 
    name: 'pudding', 
    emoji: '🍮', 
    colors: ['#fff3cd', '#fff9e6', '#fffef5'],
    width: 70 
  },
  { 
    name: 'macaron', 
    emoji: '🍡', 
    colors: ['#e6b3ff', '#f0d9ff', '#f9f0ff'],
    width: 55 
  }
];

// 移動中的甜點
let movingDessert = null;

// 已放置的甜點塔
let tower = [];

// 粒子效果
let particles = [];

// 初始化遊戲
function init() {
  // 底座
  tower.push({
    x: canvas.width / 2,
    y: canvas.height - 30,
    width: 150,
    height: 30,
    type: { name: 'base', colors: ['#8b7355', '#a0826d', '#b8956a'] }
  });
  
  spawnNewDessert();
}

// 生成新甜點
function spawnNewDessert() {
  const type = dessertTypes[Math.floor(Math.random() * dessertTypes.length)];
  const startX = Math.random() > 0.5 ? -type.width : canvas.width;
  
  movingDessert = {
    x: startX,
    y: 100,
    width: type.width,
    height: 35,
    type: type,
    direction: startX < 0 ? 1 : -1,
    speed: speed
  };
}

// 更新遊戲
function update() {
  if (gameState !== 'playing') return;
  
  // 更新移動中的甜點
  if (movingDessert) {
    movingDessert.x += movingDessert.direction * movingDessert.speed;
    
    // 碰到邊界反彈
    if (movingDessert.x <= 0) {
      movingDessert.x = 0;
      movingDessert.direction = 1;
    } else if (movingDessert.x + movingDessert.width >= canvas.width) {
      movingDessert.x = canvas.width - movingDessert.width;
      movingDessert.direction = -1;
    }
  }
  
  // 更新粒子
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.life--;
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.2; // 重力
    p.alpha -= 0.02;
    
    if (p.life <= 0) {
      particles.splice(i, 1);
    }
  }
}

// 繪製甜點
function drawDessert(dessert) {
  const { x, y, width, height, type } = dessert;
  
  // 繪製甜點本體
  const gradient = ctx.createLinearGradient(x, y, x, y + height);
  gradient.addColorStop(0, type.colors[0]);
  gradient.addColorStop(0.5, type.colors[1]);
  gradient.addColorStop(1, type.colors[2]);
  
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.roundRect(x, y, width, height, 10);
  ctx.fill();
  
  // 邊框
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
  ctx.lineWidth = 2;
  ctx.stroke();
  
  // 繪製 emoji
  ctx.font = '30px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(type.emoji, x + width / 2, y + height / 2);
  
  // 裝飾點點
  ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
  for (let i = 0; i < 3; i++) {
    const dotX = x + (i + 1) * (width / 4);
    const dotY = y + height - 8;
    ctx.beginPath();
    ctx.arc(dotX, dotY, 2, 0, Math.PI * 2);
    ctx.fill();
  }
}

// 繪製遊戲
function draw() {
  // 清空畫布
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // 繪製背景裝飾
  drawBackground();
  
  // 繪製塔
  for (const dessert of tower) {
    drawDessert(dessert);
  }
  
  // 繪製移動中的甜點
  if (movingDessert) {
    // 陰影效果
    ctx.save();
    ctx.shadowBlur = 15;
    ctx.shadowColor = 'rgba(255, 105, 180, 0.5)';
    drawDessert(movingDessert);
    ctx.restore();
    
    // 繪製虛線預覽
    const topDessert = tower[tower.length - 1];
    ctx.setLineDash([5, 5]);
    ctx.strokeStyle = 'rgba(255, 105, 180, 0.3)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(movingDessert.x + movingDessert.width / 2, movingDessert.y + movingDessert.height);
    ctx.lineTo(movingDessert.x + movingDessert.width / 2, topDessert.y);
    ctx.stroke();
    ctx.setLineDash([]);
  }
  
  // 繪製粒子
  for (const p of particles) {
    ctx.globalAlpha = p.alpha;
    ctx.fillStyle = p.color;
    
    if (p.type === 'star') {
      // 星星
      ctx.font = p.size + 'px Arial';
      ctx.fillText('✨', p.x, p.y);
    } else if (p.type === 'heart') {
      // 愛心
      ctx.font = p.size + 'px Arial';
      ctx.fillText('💖', p.x, p.y);
    } else {
      // 圓形粒子
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  ctx.globalAlpha = 1;
}

// 繪製背景裝飾
function drawBackground() {
  // 繪製一些可愛的星星
  ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
  for (let i = 0; i < 10; i++) {
    const x = (i * 73 + Date.now() * 0.01) % canvas.width;
    const y = (i * 97) % canvas.height;
    ctx.font = '15px Arial';
    ctx.fillText('⭐', x, y);
  }
}

// 放下甜點
function dropDessert() {
  if (!movingDessert || gameState !== 'playing') return;
  
  // 首次點擊後隱藏說明文字
  if (score === 0) {
    const instructions = document.getElementById('instructions');
    instructions.style.transition = 'opacity 0.5s';
    instructions.style.opacity = '0';
    setTimeout(() => {
      instructions.style.display = 'none';
    }, 500);
  }
  
  const topDessert = tower[tower.length - 1];
  
  // 計算重疊部分
  const left = Math.max(movingDessert.x, topDessert.x);
  const right = Math.min(
    movingDessert.x + movingDessert.width,
    topDessert.x + topDessert.width
  );
  const overlap = right - left;
  
  // 檢查是否有重疊
  if (overlap <= 0) {
    // 遊戲結束
    gameOver();
    return;
  }
  
  // 計算新甜點的位置和寬度
  const newWidth = overlap;
  const newX = left;
  const newY = topDessert.y - movingDessert.height;
  
  // 切掉多餘的部分（創建掉落效果）
  if (newWidth < movingDessert.width) {
    // 左邊掉落
    if (movingDessert.x < topDessert.x) {
      createFallingPiece(
        movingDessert.x,
        newY,
        topDessert.x - movingDessert.x,
        movingDessert.height,
        movingDessert.type,
        -1
      );
    }
    // 右邊掉落
    if (movingDessert.x + movingDessert.width > topDessert.x + topDessert.width) {
      const rightX = topDessert.x + topDessert.width;
      createFallingPiece(
        rightX,
        newY,
        movingDessert.x + movingDessert.width - rightX,
        movingDessert.height,
        movingDessert.type,
        1
      );
    }
  }
  
  // 加入塔中
  tower.push({
    x: newX,
    y: newY,
    width: newWidth,
    height: movingDessert.height,
    type: movingDessert.type
  });
  
  // 更新分數
  score++;
  document.getElementById('score').textContent = `🍰 高度: ${score}`;
  
  // 升級
  if (score % 10 === 0) {
    level++;
    speed += 0.3;
    document.getElementById('level').textContent = `Level ${level}`;
    createCelebration(newX + newWidth / 2, newY);
  }
  
  // 創建成功放置的特效
  createParticles(newX + newWidth / 2, newY, movingDessert.type.colors[0]);
  
  // 播放音效
  playSound('place', overlap / movingDessert.width);
  
  // 生成新甜點
  movingDessert = null;
  setTimeout(spawnNewDessert, 300);
  
  // 如果塔太高，向下移動畫面
  if (newY < 150) {
    const shift = 150 - newY;
    for (const dessert of tower) {
      dessert.y += shift;
    }
  }
}

// 創建掉落的甜點碎片
function createFallingPiece(x, y, width, height, type, direction) {
  const piece = {
    x: x,
    y: y,
    width: width,
    height: height,
    type: type,
    vx: direction * 2,
    vy: -2,
    rotation: 0,
    rotSpeed: direction * 0.1
  };
  
  // 動畫掉落效果
  const animate = () => {
    piece.vy += 0.3;
    piece.x += piece.vx;
    piece.y += piece.vy;
    piece.rotation += piece.rotSpeed;
    
    ctx.save();
    ctx.translate(piece.x + piece.width / 2, piece.y + piece.height / 2);
    ctx.rotate(piece.rotation);
    ctx.globalAlpha = Math.max(0, 1 - piece.y / canvas.height);
    
    const gradient = ctx.createLinearGradient(-piece.width / 2, -piece.height / 2, -piece.width / 2, piece.height / 2);
    gradient.addColorStop(0, type.colors[0]);
    gradient.addColorStop(0.5, type.colors[1]);
    gradient.addColorStop(1, type.colors[2]);
    
    ctx.fillStyle = gradient;
    ctx.fillRect(-piece.width / 2, -piece.height / 2, piece.width, piece.height);
    
    ctx.restore();
    
    if (piece.y < canvas.height) {
      requestAnimationFrame(animate);
    }
  };
  
  animate();
}

// 創建粒子效果
function createParticles(x, y, color) {
  for (let i = 0; i < 15; i++) {
    particles.push({
      x: x,
      y: y,
      vx: (Math.random() - 0.5) * 5,
      vy: (Math.random() - 0.5) * 5 - 2,
      size: Math.random() * 4 + 2,
      color: color,
      type: 'circle',
      life: 50,
      alpha: 1
    });
  }
}

// 創建慶祝效果
function createCelebration(x, y) {
  for (let i = 0; i < 20; i++) {
    particles.push({
      x: x,
      y: y,
      vx: (Math.random() - 0.5) * 8,
      vy: (Math.random() - 0.5) * 8 - 3,
      size: Math.random() * 15 + 15,
      type: i % 2 === 0 ? 'star' : 'heart',
      life: 60,
      alpha: 1
    });
  }
  
  playSound('levelup');
}

// 遊戲結束
function gameOver() {
  gameState = 'gameover';
  
  // 顯示結束畫面
  document.getElementById('final-score').textContent = `最終高度: ${score} 層！`;
  document.getElementById('game-over').style.display = 'block';
  
  playSound('gameover');
  
  // 創建遊戲結束特效
  for (let i = 0; i < 30; i++) {
    setTimeout(() => {
      particles.push({
        x: Math.random() * canvas.width,
        y: canvas.height,
        vx: (Math.random() - 0.5) * 4,
        vy: -Math.random() * 10 - 5,
        size: Math.random() * 20 + 10,
        type: 'star',
        life: 80,
        alpha: 1
      });
    }, i * 50);
  }
}

// 重新開始
function restart() {
  gameState = 'playing';
  score = 0;
  level = 1;
  speed = 2;
  tower = [];
  particles = [];
  movingDessert = null;
  
  document.getElementById('score').textContent = '🍰 高度: 0';
  document.getElementById('level').textContent = 'Level 1';
  document.getElementById('game-over').style.display = 'none';
  
  // 重新顯示說明文字
  const instructions = document.getElementById('instructions');
  instructions.style.display = 'block';
  instructions.style.opacity = '1';
  
  init();
}

// 音效
function playSound(type, intensity = 1) {
  try {
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const oscillator = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    
    switch(type) {
      case 'place':
        oscillator.frequency.setValueAtTime(400 + intensity * 200, audioCtx.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(600 + intensity * 200, audioCtx.currentTime + 0.1);
        gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        oscillator.stop(audioCtx.currentTime + 0.1);
        break;
      case 'levelup':
        oscillator.frequency.setValueAtTime(523, audioCtx.currentTime);
        oscillator.frequency.setValueAtTime(659, audioCtx.currentTime + 0.1);
        oscillator.frequency.setValueAtTime(784, audioCtx.currentTime + 0.2);
        oscillator.frequency.setValueAtTime(1047, audioCtx.currentTime + 0.3);
        gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
        oscillator.stop(audioCtx.currentTime + 0.4);
        break;
      case 'gameover':
        oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.5);
        gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
        oscillator.stop(audioCtx.currentTime + 0.5);
        break;
    }
    
    oscillator.start(audioCtx.currentTime);
  } catch(e) {}
}

// 事件監聽
canvas.addEventListener('click', dropDessert);
document.getElementById('restart-btn').addEventListener('click', restart);

// Canvas 的 roundRect polyfill（舊瀏覽器相容）
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {
    this.moveTo(x + radius, y);
    this.lineTo(x + width - radius, y);
    this.quadraticCurveTo(x + width, y, x + width, y + radius);
    this.lineTo(x + width, y + height - radius);
    this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    this.lineTo(x + radius, y + height);
    this.quadraticCurveTo(x, y + height, x, y + height - radius);
    this.lineTo(x, y + radius);
    this.quadraticCurveTo(x, y, x + radius, y);
  };
}

// 遊戲循環
function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

// 啟動遊戲
init();
gameLoop();
</script>
</body>
</html>
