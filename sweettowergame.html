<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>ğŸ° Sweet Tower ç”œé»å¡”ç–Šç–Šæ¨‚</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: linear-gradient(180deg, #fff5f7 0%, #ffe4e9 50%, #ffd4e0 100%);
    overflow: hidden;
    font-family: 'Comic Sans MS', 'Arial', sans-serif;
    height: 100vh;
    position: relative;
  }
  
  /* å¯æ„›çš„é›²æœµèƒŒæ™¯ */
  .cloud {
    position: absolute;
    background: rgba(255, 255, 255, 0.7);
    border-radius: 100px;
    animation: float-cloud 20s infinite linear;
  }
  .cloud::before, .cloud::after {
    content: '';
    position: absolute;
    background: rgba(255, 255, 255, 0.7);
    border-radius: 100px;
  }
  @keyframes float-cloud {
    from { transform: translateX(-200px); }
    to { transform: translateX(100vw); }
  }
  
  canvas {
    display: block;
    margin: 0 auto;
    max-width: 100%;
    max-height: 100vh;
    box-shadow: 0 10px 40px rgba(255, 182, 193, 0.3);
    border-radius: 20px;
  }
  
  #game-container {
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
  }
  
  #ui {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    text-align: center;
    z-index: 10;
  }
  
  #score {
    font-size: 36px;
    font-weight: bold;
    color: #ff69b4;
    text-shadow: 2px 2px 4px rgba(255, 105, 180, 0.3);
    margin-bottom: 10px;
  }
  
  #level {
    font-size: 20px;
    color: #ff8fab;
    background: rgba(255, 255, 255, 0.8);
    padding: 8px 20px;
    border-radius: 20px;
    display: inline-block;
    box-shadow: 0 4px 10px rgba(255, 182, 193, 0.3);
  }
  
  #instructions {
    position: fixed;
    top: 100px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(255, 255, 255, 0.9);
    padding: 12px 25px;
    border-radius: 20px;
    font-size: 16px;
    color: #ff69b4;
    box-shadow: 0 4px 15px rgba(255, 182, 193, 0.4);
    font-weight: bold;
    animation: fade-hint 3s ease-in-out infinite;
  }
  
  @keyframes fade-hint {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
  }
  
  #game-over {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(255, 255, 255, 0.95);
    padding: 40px 60px;
    border-radius: 30px;
    text-align: center;
    box-shadow: 0 10px 40px rgba(255, 105, 180, 0.4);
    display: none;
    z-index: 100;
  }
  
  #game-over h1 {
    font-size: 48px;
    color: #ff69b4;
    margin-bottom: 20px;
  }
  
  #final-score {
    font-size: 32px;
    color: #ff8fab;
    margin-bottom: 30px;
  }
  
  #restart-btn {
    background: linear-gradient(135deg, #ff69b4, #ff8fab);
    color: white;
    border: none;
    padding: 15px 40px;
    font-size: 24px;
    border-radius: 25px;
    cursor: pointer;
    font-weight: bold;
    box-shadow: 0 6px 20px rgba(255, 105, 180, 0.4);
    transition: transform 0.2s;
  }
  
  #restart-btn:hover {
    transform: scale(1.1);
  }
  
  #restart-btn:active {
    transform: scale(0.95);
  }
  
  .sparkle {
    position: fixed;
    pointer-events: none;
    font-size: 20px;
    animation: sparkle-float 1s ease-out forwards;
  }
  
  @keyframes sparkle-float {
    to {
      transform: translateY(-100px) scale(1.5);
      opacity: 0;
    }
  }
</style>
<link rel="stylesheet" href="mobile-ui.css">
</head>
<body>
<!-- èƒŒæ™¯é›²æœµ -->
<div class="cloud" style="width:80px;height:40px;top:10%;left:-100px;animation-delay:0s;"></div>
<div class="cloud" style="width:120px;height:50px;top:25%;left:-150px;animation-delay:5s;"></div>
<div class="cloud" style="width:100px;height:45px;top:60%;left:-120px;animation-delay:10s;"></div>
<div class="cloud" style="width:90px;height:42px;top:80%;left:-110px;animation-delay:15s;"></div>

<div id="game-container">
  <canvas id="game"></canvas>
</div>

<div id="ui">
  <div id="score">ğŸ° é«˜åº¦: 0</div>
  <div id="level">Level 1</div>
</div>

<div id="instructions">é»æ“Šæ”¾ä¸‹ç”œé»ï¼ç–Šå¾—è¶Šé«˜è¶Šå¥½ ğŸ‚</div>

<div id="game-over">
  <h1>ğŸ‰ éŠæˆ²çµæŸ ğŸ‰</h1>
  <div id="final-score">æœ€çµ‚é«˜åº¦: 0</div>
  <button id="restart-btn">å†ç©ä¸€æ¬¡ï¼</button>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = 400;
canvas.height = 700;

// éŠæˆ²ç‹€æ…‹
let gameState = 'playing'; // playing, gameover
let score = 0;
let level = 1;
let speed = 2;

// ç”œé»é¡å‹
const dessertTypes = [
  { 
    name: 'cake', 
    emoji: 'ğŸ°', 
    colors: ['#ffb6d9', '#fff0f5', '#ffe4e9'],
    width: 80 
  },
  { 
    name: 'cupcake', 
    emoji: 'ğŸ§', 
    colors: ['#ffd4e0', '#ffe4f0', '#fff5f7'],
    width: 70 
  },
  { 
    name: 'donut', 
    emoji: 'ğŸ©', 
    colors: ['#ffb3d9', '#ffd6e8', '#ffe9f2'],
    width: 75 
  },
  { 
    name: 'pie', 
    emoji: 'ğŸ¥§', 
    colors: ['#ffc4dd', '#ffe0ed', '#fff0f5'],
    width: 85 
  },
  { 
    name: 'cookie', 
    emoji: 'ğŸª', 
    colors: ['#d4a574', '#e6c8a0', '#f5e6d3'],
    width: 65 
  },
  { 
    name: 'icecream', 
    emoji: 'ğŸ¦', 
    colors: ['#ffd9ec', '#ffe9f5', '#fff5fa'],
    width: 60 
  },
  { 
    name: 'pudding', 
    emoji: 'ğŸ®', 
    colors: ['#fff3cd', '#fff9e6', '#fffef5'],
    width: 70 
  },
  { 
    name: 'macaron', 
    emoji: 'ğŸ¡', 
    colors: ['#e6b3ff', '#f0d9ff', '#f9f0ff'],
    width: 55 
  }
];

// ç§»å‹•ä¸­çš„ç”œé»
let movingDessert = null;

// å·²æ”¾ç½®çš„ç”œé»å¡”
let tower = [];

// ç²’å­æ•ˆæœ
let particles = [];

// åˆå§‹åŒ–éŠæˆ²
function init() {
  // åº•åº§
  tower.push({
    x: canvas.width / 2,
    y: canvas.height - 30,
    width: 150,
    height: 30,
    type: { name: 'base', colors: ['#8b7355', '#a0826d', '#b8956a'] }
  });
  
  spawnNewDessert();
}

// ç”Ÿæˆæ–°ç”œé»
function spawnNewDessert() {
  const type = dessertTypes[Math.floor(Math.random() * dessertTypes.length)];
  const startX = Math.random() > 0.5 ? -type.width : canvas.width;
  
  movingDessert = {
    x: startX,
    y: 100,
    width: type.width,
    height: 35,
    type: type,
    direction: startX < 0 ? 1 : -1,
    speed: speed
  };
}

// æ›´æ–°éŠæˆ²
function update() {
  if (gameState !== 'playing') return;
  
  // æ›´æ–°ç§»å‹•ä¸­çš„ç”œé»
  if (movingDessert) {
    movingDessert.x += movingDessert.direction * movingDessert.speed;
    
    // ç¢°åˆ°é‚Šç•Œåå½ˆ
    if (movingDessert.x <= 0) {
      movingDessert.x = 0;
      movingDessert.direction = 1;
    } else if (movingDessert.x + movingDessert.width >= canvas.width) {
      movingDessert.x = canvas.width - movingDessert.width;
      movingDessert.direction = -1;
    }
  }
  
  // æ›´æ–°ç²’å­
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.life--;
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.2; // é‡åŠ›
    p.alpha -= 0.02;
    
    if (p.life <= 0) {
      particles.splice(i, 1);
    }
  }
}

// ç¹ªè£½ç”œé»
function drawDessert(dessert) {
  const { x, y, width, height, type } = dessert;
  
  // ç¹ªè£½ç”œé»æœ¬é«”
  const gradient = ctx.createLinearGradient(x, y, x, y + height);
  gradient.addColorStop(0, type.colors[0]);
  gradient.addColorStop(0.5, type.colors[1]);
  gradient.addColorStop(1, type.colors[2]);
  
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.roundRect(x, y, width, height, 10);
  ctx.fill();
  
  // é‚Šæ¡†
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
  ctx.lineWidth = 2;
  ctx.stroke();
  
  // ç¹ªè£½ emoji
  ctx.font = '30px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(type.emoji, x + width / 2, y + height / 2);
  
  // è£é£¾é»é»
  ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
  for (let i = 0; i < 3; i++) {
    const dotX = x + (i + 1) * (width / 4);
    const dotY = y + height - 8;
    ctx.beginPath();
    ctx.arc(dotX, dotY, 2, 0, Math.PI * 2);
    ctx.fill();
  }
}

// ç¹ªè£½éŠæˆ²
function draw() {
  // æ¸…ç©ºç•«å¸ƒ
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // ç¹ªè£½èƒŒæ™¯è£é£¾
  drawBackground();
  
  // ç¹ªè£½å¡”
  for (const dessert of tower) {
    drawDessert(dessert);
  }
  
  // ç¹ªè£½ç§»å‹•ä¸­çš„ç”œé»
  if (movingDessert) {
    // é™°å½±æ•ˆæœ
    ctx.save();
    ctx.shadowBlur = 15;
    ctx.shadowColor = 'rgba(255, 105, 180, 0.5)';
    drawDessert(movingDessert);
    ctx.restore();
    
    // ç¹ªè£½è™›ç·šé è¦½
    const topDessert = tower[tower.length - 1];
    ctx.setLineDash([5, 5]);
    ctx.strokeStyle = 'rgba(255, 105, 180, 0.3)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(movingDessert.x + movingDessert.width / 2, movingDessert.y + movingDessert.height);
    ctx.lineTo(movingDessert.x + movingDessert.width / 2, topDessert.y);
    ctx.stroke();
    ctx.setLineDash([]);
  }
  
  // ç¹ªè£½ç²’å­
  for (const p of particles) {
    ctx.globalAlpha = p.alpha;
    ctx.fillStyle = p.color;
    
    if (p.type === 'star') {
      // æ˜Ÿæ˜Ÿ
      ctx.font = p.size + 'px Arial';
      ctx.fillText('âœ¨', p.x, p.y);
    } else if (p.type === 'heart') {
      // æ„›å¿ƒ
      ctx.font = p.size + 'px Arial';
      ctx.fillText('ğŸ’–', p.x, p.y);
    } else {
      // åœ“å½¢ç²’å­
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  ctx.globalAlpha = 1;
}

// ç¹ªè£½èƒŒæ™¯è£é£¾
function drawBackground() {
  // ç¹ªè£½ä¸€äº›å¯æ„›çš„æ˜Ÿæ˜Ÿ
  ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
  for (let i = 0; i < 10; i++) {
    const x = (i * 73 + Date.now() * 0.01) % canvas.width;
    const y = (i * 97) % canvas.height;
    ctx.font = '15px Arial';
    ctx.fillText('â­', x, y);
  }
}

// æ”¾ä¸‹ç”œé»
function dropDessert() {
  if (!movingDessert || gameState !== 'playing') return;
  
  // é¦–æ¬¡é»æ“Šå¾Œéš±è—èªªæ˜æ–‡å­—
  if (score === 0) {
    const instructions = document.getElementById('instructions');
    instructions.style.transition = 'opacity 0.5s';
    instructions.style.opacity = '0';
    setTimeout(() => {
      instructions.style.display = 'none';
    }, 500);
  }
  
  const topDessert = tower[tower.length - 1];
  
  // è¨ˆç®—é‡ç–Šéƒ¨åˆ†
  const left = Math.max(movingDessert.x, topDessert.x);
  const right = Math.min(
    movingDessert.x + movingDessert.width,
    topDessert.x + topDessert.width
  );
  const overlap = right - left;
  
  // æª¢æŸ¥æ˜¯å¦æœ‰é‡ç–Š
  if (overlap <= 0) {
    // éŠæˆ²çµæŸ
    gameOver();
    return;
  }
  
  // è¨ˆç®—æ–°ç”œé»çš„ä½ç½®å’Œå¯¬åº¦
  const newWidth = overlap;
  const newX = left;
  const newY = topDessert.y - movingDessert.height;
  
  // åˆ‡æ‰å¤šé¤˜çš„éƒ¨åˆ†ï¼ˆå‰µå»ºæ‰è½æ•ˆæœï¼‰
  if (newWidth < movingDessert.width) {
    // å·¦é‚Šæ‰è½
    if (movingDessert.x < topDessert.x) {
      createFallingPiece(
        movingDessert.x,
        newY,
        topDessert.x - movingDessert.x,
        movingDessert.height,
        movingDessert.type,
        -1
      );
    }
    // å³é‚Šæ‰è½
    if (movingDessert.x + movingDessert.width > topDessert.x + topDessert.width) {
      const rightX = topDessert.x + topDessert.width;
      createFallingPiece(
        rightX,
        newY,
        movingDessert.x + movingDessert.width - rightX,
        movingDessert.height,
        movingDessert.type,
        1
      );
    }
  }
  
  // åŠ å…¥å¡”ä¸­
  tower.push({
    x: newX,
    y: newY,
    width: newWidth,
    height: movingDessert.height,
    type: movingDessert.type
  });
  
  // æ›´æ–°åˆ†æ•¸
  score++;
  document.getElementById('score').textContent = `ğŸ° é«˜åº¦: ${score}`;
  
  // å‡ç´š
  if (score % 10 === 0) {
    level++;
    speed += 0.3;
    document.getElementById('level').textContent = `Level ${level}`;
    createCelebration(newX + newWidth / 2, newY);
  }
  
  // å‰µå»ºæˆåŠŸæ”¾ç½®çš„ç‰¹æ•ˆ
  createParticles(newX + newWidth / 2, newY, movingDessert.type.colors[0]);
  
  // æ’­æ”¾éŸ³æ•ˆ
  playSound('place', overlap / movingDessert.width);
  
  // ç”Ÿæˆæ–°ç”œé»
  movingDessert = null;
  setTimeout(spawnNewDessert, 300);
  
  // å¦‚æœå¡”å¤ªé«˜ï¼Œå‘ä¸‹ç§»å‹•ç•«é¢
  if (newY < 150) {
    const shift = 150 - newY;
    for (const dessert of tower) {
      dessert.y += shift;
    }
  }
}

// å‰µå»ºæ‰è½çš„ç”œé»ç¢ç‰‡
function createFallingPiece(x, y, width, height, type, direction) {
  const piece = {
    x: x,
    y: y,
    width: width,
    height: height,
    type: type,
    vx: direction * 2,
    vy: -2,
    rotation: 0,
    rotSpeed: direction * 0.1
  };
  
  // å‹•ç•«æ‰è½æ•ˆæœ
  const animate = () => {
    piece.vy += 0.3;
    piece.x += piece.vx;
    piece.y += piece.vy;
    piece.rotation += piece.rotSpeed;
    
    ctx.save();
    ctx.translate(piece.x + piece.width / 2, piece.y + piece.height / 2);
    ctx.rotate(piece.rotation);
    ctx.globalAlpha = Math.max(0, 1 - piece.y / canvas.height);
    
    const gradient = ctx.createLinearGradient(-piece.width / 2, -piece.height / 2, -piece.width / 2, piece.height / 2);
    gradient.addColorStop(0, type.colors[0]);
    gradient.addColorStop(0.5, type.colors[1]);
    gradient.addColorStop(1, type.colors[2]);
    
    ctx.fillStyle = gradient;
    ctx.fillRect(-piece.width / 2, -piece.height / 2, piece.width, piece.height);
    
    ctx.restore();
    
    if (piece.y < canvas.height) {
      requestAnimationFrame(animate);
    }
  };
  
  animate();
}

// å‰µå»ºç²’å­æ•ˆæœ
function createParticles(x, y, color) {
  for (let i = 0; i < 15; i++) {
    particles.push({
      x: x,
      y: y,
      vx: (Math.random() - 0.5) * 5,
      vy: (Math.random() - 0.5) * 5 - 2,
      size: Math.random() * 4 + 2,
      color: color,
      type: 'circle',
      life: 50,
      alpha: 1
    });
  }
}

// å‰µå»ºæ…¶ç¥æ•ˆæœ
function createCelebration(x, y) {
  for (let i = 0; i < 20; i++) {
    particles.push({
      x: x,
      y: y,
      vx: (Math.random() - 0.5) * 8,
      vy: (Math.random() - 0.5) * 8 - 3,
      size: Math.random() * 15 + 15,
      type: i % 2 === 0 ? 'star' : 'heart',
      life: 60,
      alpha: 1
    });
  }
  
  playSound('levelup');
}

// éŠæˆ²çµæŸ
function gameOver() {
  gameState = 'gameover';
  
  // é¡¯ç¤ºçµæŸç•«é¢
  document.getElementById('final-score').textContent = `æœ€çµ‚é«˜åº¦: ${score} å±¤ï¼`;
  document.getElementById('game-over').style.display = 'block';
  
  playSound('gameover');
  
  // å‰µå»ºéŠæˆ²çµæŸç‰¹æ•ˆ
  for (let i = 0; i < 30; i++) {
    setTimeout(() => {
      particles.push({
        x: Math.random() * canvas.width,
        y: canvas.height,
        vx: (Math.random() - 0.5) * 4,
        vy: -Math.random() * 10 - 5,
        size: Math.random() * 20 + 10,
        type: 'star',
        life: 80,
        alpha: 1
      });
    }, i * 50);
  }
}

// é‡æ–°é–‹å§‹
function restart() {
  gameState = 'playing';
  score = 0;
  level = 1;
  speed = 2;
  tower = [];
  particles = [];
  movingDessert = null;
  
  document.getElementById('score').textContent = 'ğŸ° é«˜åº¦: 0';
  document.getElementById('level').textContent = 'Level 1';
  document.getElementById('game-over').style.display = 'none';
  
  // é‡æ–°é¡¯ç¤ºèªªæ˜æ–‡å­—
  const instructions = document.getElementById('instructions');
  instructions.style.display = 'block';
  instructions.style.opacity = '1';
  
  init();
}

// éŸ³æ•ˆ
function playSound(type, intensity = 1) {
  try {
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const oscillator = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    
    switch(type) {
      case 'place':
        oscillator.frequency.setValueAtTime(400 + intensity * 200, audioCtx.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(600 + intensity * 200, audioCtx.currentTime + 0.1);
        gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        oscillator.stop(audioCtx.currentTime + 0.1);
        break;
      case 'levelup':
        oscillator.frequency.setValueAtTime(523, audioCtx.currentTime);
        oscillator.frequency.setValueAtTime(659, audioCtx.currentTime + 0.1);
        oscillator.frequency.setValueAtTime(784, audioCtx.currentTime + 0.2);
        oscillator.frequency.setValueAtTime(1047, audioCtx.currentTime + 0.3);
        gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
        oscillator.stop(audioCtx.currentTime + 0.4);
        break;
      case 'gameover':
        oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.5);
        gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
        oscillator.stop(audioCtx.currentTime + 0.5);
        break;
    }
    
    oscillator.start(audioCtx.currentTime);
  } catch(e) {}
}

// äº‹ä»¶ç›£è½
canvas.addEventListener('click', dropDessert);
document.getElementById('restart-btn').addEventListener('click', restart);

// Canvas çš„ roundRect polyfillï¼ˆèˆŠç€è¦½å™¨ç›¸å®¹ï¼‰
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {
    this.moveTo(x + radius, y);
    this.lineTo(x + width - radius, y);
    this.quadraticCurveTo(x + width, y, x + width, y + radius);
    this.lineTo(x + width, y + height - radius);
    this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    this.lineTo(x + radius, y + height);
    this.quadraticCurveTo(x, y + height, x, y + height - radius);
    this.lineTo(x, y + radius);
    this.quadraticCurveTo(x, y, x + radius, y);
  };
}

// éŠæˆ²å¾ªç’°
function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

// å•Ÿå‹•éŠæˆ²
init();
gameLoop();
</script>
<script src="mobile-nav.js"></script>
</body>
</html>
